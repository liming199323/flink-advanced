# 状态管理
## 什么是状态
### 无状态举例
首先举一个无状态计算的例子：消费延迟计算。假设现在有一个消息队列，消息队列中有一个生产者持续往消费队列写入消息，多个消费者分别从消息队列中读取消息。

输入：
```
{
  "timestamp": 1555516800,
  "offset": {
    "producer": 15,  // 生产者生产了 15条消息
    "consumer0": 10, // 消费者0 消费了10条，5条未消费
    "consumer1": 7,
    "consumer2": 12
  }
}
```
输出：
```
{
  "timestamp": 1555516800,
  "lag": {
    "consumer0": 5, // 消费者0 消费了10条，5条未消费
    "consumer1": 8,
    "consumer2": 3
  }
}
```
根据 Flink 的原理，此处需进行 Map 操作。Map 首先把消息读取进来，然后分别相减，即可知道每个 consumer 分别落后了几条。Map 一直往下发，则会得出最终结果。

大家会发现，在这种模式的计算中，无论这条输入进来多少次，输出的结果都是一样的，因为单条输入中已经包含了所需的所有信息。消费落后等于生产者减去消费者。
生产者的消费在单条数据中可以得到，消费者的数据也可以在单条数据中得到，所以**相同输入可以得到相同输出，这就是一个无状态的计算**。

### 有状态举例
以访问日志统计量的例子进行说明，比如当前拿到一个 Nginx 访问日志，一条日志表示一个请求，记录该请求从哪里来，访问的哪个地址，需要实时统计每个地址总共被访问了多少次，也即每个 API 被调用了多少次。

输入：
```
[
  {
    "timestamp": 1555516800,
    "url": "/api/a"
  },
  {
    "timestamp": 1555516801,
    "url": "/api/b"
  },
  {
    "timestamp": 1555516802,
    "url": "/api/a"
  },
  {
    "timestamp": 1555516803,
    "url": "/api/b"
  }
]
```
输出：
```
[
  {
    "url": "/api/a",
    "count": 2
  },
  {
    "url": "/api/b",
    "count": 2
  }
]
```
相同输入可能得到不同输出。输出的结果取决于当前请求的 API 地址之前累计被访问过多少次。第一条过来累计是 0 次，count = 1，第二条过来 API 的访问已经有一次了，所以 /api/a 访问累计次数 count=2。

单条数据其实仅包含当前这次访问的信息，而不包含所有的信息。要得到这个结果，还需要依赖 API 累计访问的量，即状态。

这个计算模式是将数据输入算子中，用来进行各种复杂的计算并输出数据。这个过程中算子会去访问之前存储在里面的状态。另外一方面，它还会把现在的数据对状态的影响实时更新，如果输入 200 条数据，最后输出就是 200 条结果。

#### 需要有状态的场景举例
- 去重：比如上游的系统数据可能会有重复，落到下游系统时希望把重复的数据都去掉。去重需要先了解哪些数据来过，哪些数据还没有来，也就是把所有的主键都记录下来，当一条数据到来后，能够看到在主键当中是否存在。
- 窗口计算：比如统计每分钟 Nginx 日志 API 被访问了多少次。窗口是一分钟计算一次，在窗口触发前，如 08:00 ~ 08:01 这个窗口，前59秒的数据来了需要先放入内存，即需要把这个窗口之内的数据先保留下来，等到 8:01 时一分钟后，再将整个窗口内触发的数据输出。未触发的窗口数据也是一种状态。
- 机器学习/深度学习：如训练的模型以及当前模型的参数也是一种状态，机器学习可能每次都用有一个数据集，需要在数据集上进行学习，对模型进行一个反馈。
- 访问历史数据：比如与昨天的数据进行对比，需要访问一些历史数据。如果每次从外部去读，对资源的消耗可能比较大，所以也希望把这些历史数据也放入状态中做对比。

## 为什么要管理状态
对于流式作业有以下要求：
- 7*24小时运行，高可靠
- 数据不丢不重，恰好计算一次
- 数据实时产出，不延迟

基于以上要求，内存的管理就会出现一些问题。
- 容量有限制：如果要做 24 小时的窗口计算，将 24 小时的数据都放到内存，可能会出现内存不足；
- 备份恢复：作业是 7*24，需要保障高可用，机器若出现故障或者宕机，需要考虑如何备份及从备份中去恢复，保证运行的作业不受影响；
- 横向扩展：假如网站的访问量不高，统计每个 API 访问次数的程序可以用单线程去运行，但如果网站访问量突然增加，单节点无法处理全部访问数据，此时需要增加几个节点进行横向扩展，这时数据的状态如何平均分配到新增加的节点也问题之一。

因此，将数据都放到内存中，并不是最合适的一种状态管理方式。

## 状态类型
Managed State 是 Flink 自动管理的 State，而 Raw State 是原生态 State，两者的区别如下：
- 从状态管理方式的方式来说，Managed State 由 Flink Runtime 管理，自动存储，自动恢复，在内存管理上有优化；而 Raw State 需要用户自己管理，需要自己序列化，Flink 不知道 State 中存入的数据是什么结构，只有用户自己知道，需要最终序列化为可存储的数据结构。
- 从状态数据结构来说，Managed State 支持已知的数据结构，如 Value、List、Map 等。而 Raw State只支持字节数组 ，所有状态都要转换为二进制字节数组才可以。
- 从推荐使用场景来说，Managed State 大多数情况下均可使用，而 Raw State 是当 Managed State 不够用时，比如需要自定义 Operator 时，推荐使用 Raw State。

### Managed State
Managed State 分为两种，一种是 **Keyed State**；另外一种是 **Operator State**。在Flink Stream模型中，Datastream 经过 keyBy 的操作可以变为 KeyedStream 。

每个 Key 对应一个 State，即一个 Operator 实例处理多个 Key，访问相应的多个 State，并由此就衍生了 Keyed State。**Keyed State 只能用在 KeyedStream 的算子中**，即在整个程序中没有 keyBy 的过程就没有办法使用 KeyedStream。

相比较而言，**Operator State 可以用于所有算子**，相对于数据源有一个更好的匹配方式，常用于 Source，例如 FlinkKafkaConsumer。
相比 Keyed State，一个 Operator 实例对应一个 State，随着并发的改变，Keyed State 中，State 随着 Key 在实例间迁移，比如原来有 1 个并发，对应的 API 请求过来，/api/a 和 /api/b 都存放在这个实例当中；
如果请求量变大，需要扩容，就会把 /api/a 的状态和 /api/b 的状态分别放在不同的节点。由于 Operator State 没有 Key，并发改变时需要选择状态如何重新分配。
其中内置了 2 种分配方式：一种是均匀分配，另外一种是将所有 State 合并为全量 State 再分发给每个实例。

- 在访问上，Keyed State 通过 RuntimeContext 访问，这需要 Operator 是一个Rich Function。Operator State 需要自己实现 CheckpointedFunction 或 ListCheckpointed 接口。
- 在数据结构上，Keyed State 支持的数据结构，比如 ValueState、ListState、ReducingState、AggregatingState 和 MapState；而 Operator State 支持的数据结构相对较少，如 ListState。

#### Keyed State
- 源码参考 `org.apache.flink.api.common.state.State` ，差异化表现为状态数据类型、访问接口方法
- 示例参考 `org.apache.flink.streaming.examples.statemachine.StateMachineExample`
### Raw State

# 参考
- `org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumerBase#unionOffsetStates`

